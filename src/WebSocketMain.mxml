<?xml version="1.0" encoding="utf-8"?>
<s:Application xmlns:fx="http://ns.adobe.com/mxml/2009" 
			   xmlns:s="library://ns.adobe.com/flex/spark" 
			   xmlns:mx="library://ns.adobe.com/flex/mx" minWidth="955" minHeight="600"
			   creationComplete="application1_creationCompleteHandler(event)">
	<s:layout>
		<s:VerticalLayout />
	</s:layout>
	<fx:Declarations>
		<!-- Place non-visual elements (e.g., services, value objects) here -->
	</fx:Declarations>
	<fx:Script>
		<![CDATA[
			
			import flash.display.*;
			import flash.events.*;
			import flash.external.*;
			import flash.net.*;
			import flash.system.*;
			import flash.utils.*;
			
			import mx.controls.*;
			import mx.core.*;
			import mx.events.*;
			import mx.utils.*;
			
			
			private var callerUrl:String;
			private var debug:Boolean = true;
			private var manualPolicyFileLoaded:Boolean = false;
			
			private var socket:WebSocket;
			
			public function setCallerUrl(url:String):void {
				callerUrl = url;
			}
			
			public function setDebug(val:Boolean):void {
				debug = val;
			}
			
			public function create(
				url:String, protocol:String,
				proxyHost:String = null, proxyPort:int = 0,
										 headers:String = null):WebSocket {
				if (!manualPolicyFileLoaded) {
					loadDefaultPolicyFile(url);
				}
				return new WebSocket(this, url, protocol, proxyHost, proxyPort, headers);
			}
			
			public function getOrigin():String {
				return (URLUtil.getProtocol(this.callerUrl) + "://" +
					URLUtil.getServerNameWithPort(this.callerUrl)).toLowerCase();
			}
			
			public function getCallerHost():String {
				return URLUtil.getServerName(this.callerUrl);
			}
			
			private function loadDefaultPolicyFile(wsUrl:String):void {
				var policyUrl:String = "xmlsocket://" + URLUtil.getServerName(wsUrl) + ":843";
				log("policy file: " + policyUrl);
				Security.loadPolicyFile(policyUrl);
			}
			
			public function loadManualPolicyFile(policyUrl:String):void {
				log("policy file: " + policyUrl);
				Security.loadPolicyFile(policyUrl);
				manualPolicyFileLoaded = true;
			}
			
			public function log(message:String):void {
				if (debug) {
					//ExternalInterface.call("webSocketLog", encodeURIComponent("[WebSocket] " + message));
					trace(message);
				}
			}
			
			public function error(message:String):void {
				ExternalInterface.call("webSocketError", encodeURIComponent("[WebSocket] " + message));
			}
			
			public function fatal(message:String):void {
				ExternalInterface.call("webSocketError", encodeURIComponent("[WebSocket] " + message));
				throw message;
			}

			protected function application1_creationCompleteHandler(event:FlexEvent):void
			{
				callerUrl = "http://localhost:8124/WebSocketMain.html";
				socket = create('ws://192.168.0.3:8124/socket.io/flashsocket', null);
				socket.addEventListener("event", onData);
			}

			protected var frame:String = '~m~';
			
			protected function onData(e:*):void{
				var event:Object = (e.target as WebSocket).receiveEvents();
				var data:Object = event[0];
				
				if ( data.type == "message" ){
					this._setTimeout();
					var msgs:Array = this._decode(data.data);
					if (msgs && msgs.length){
						for (var i:int = 0, l:int = msgs.length; i < l; i++){
							this._onMessage(msgs[i]);
						}
					}
				}
			}
			private function _setTimeout():void{
				
			}
			public var sessionid:String;
			public var connected:Boolean;
			public var connecting:Boolean;
			
			private function _onMessage(message:String):void{
				if (!this.sessionid){
					this.sessionid = message;
					this._onConnect();
				} else if (message.substr(0, 3) == '~h~'){
					this._onHeartbeat(message.substr(3));
				} else if (message.substr(0, 3) == '~j~'){
					//this.base._onMessage(JSON.parse(message.substr(3)));
				} else {
					//this.emit('message', message);
				}
			}
			private function _decode(data:String):Array{
				var messages:Array = [], number:*, n:*;
				do {
					if (data.substr(0, 3) !== frame) return messages;
					data = data.substr(3);
					number = '', n = '';
					for (var i:int = 0, l:int = data.length; i < l; i++){
						n = Number(data.substr(i, 1));
						if (data.substr(i, 1) == n){
							number += n;
						} else {	
							data = data.substr(number.length + frame.length);
							number = Number(number);
							break;
						} 
					}
					messages.push(data.substr(0, number)); // here
					data = data.substr(number);
				} while(data !== '');
				return messages;
			}
			
			private function _onHeartbeat(heartbeat:*):void{
				var enc:String = '~h~' + heartbeat;
				send( enc ); // echo
			};
			
			private function send(msg:String):void{
				socket.send(_encode(msg));
			}
			
			private function _onConnect():void{
				this.connected = true;
				this.connecting = false;
				//this.base._onConnect();
				//this._setTimeout();
			};
			
			private function _encode(messages:*):String{
				var ret = '', message,
					messages =  (messages is Array) ? messages : [messages];
				for (var i = 0, l = messages.length; i < l; i++){
					message = messages[i] === null || messages[i] === undefined ? '' : (messages[i].toString());
					ret += frame + message.length + frame + message;
				}
				return ret;
			};
			
		]]>
	</fx:Script>
	
	<s:TextInput id="text" />
	<s:Button label="send" click="send(text.text)" />
</s:Application>
